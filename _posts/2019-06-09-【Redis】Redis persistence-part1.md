---
layout:         page
title:         【Redis】Redis persistence-part1
subtitle:       
date:           2019-06-09
author:         翼
header-img: image/bg.jpg
catalog: true
tags:
---

> 这篇文章翻译自Redis官网。原文链接在[这里](https://redis.io/topics/persistence)

Redis提供了不同的持久化选项：
1. **RDB** 持久化以指定的时间间隔生成数据集的时间点快照。
2. **AOF** 持久化会记录Redis服务器接收到的每条写操作，这些被记录的操作在服务器重启时会被再次执行————这样就能重建原始的数据集。命令（写操作）是以append-only方式记录的，记录的格式与Redis协议本身的格式相同。
3. 如果你的数据只需要在服务器运行期间存在，完全可以禁用所有的持久化选项。
4. 也可以在同一个Redis服务实例中组合使用AOF和RDB。需要注意的是：这种持久化方式下，Redis重启时会使用AOF文件来重建原始数据集（因为AOF文件通常被认为更完整）。

#### RDB的优势
1. RDB是Redis数据的一种非常紧凑的、单文件、时间点快照形式的表示形式。RDB文件非常适合用于备份。比如，你可能会为最近30天中每天24小时中的每小时生成一个RDB文件。这使得万一出现服务故障时，你能很简单地恢复到不同版本的数据集。
2. RDB在故障恢复时是很方便的，它本身是一个单一、紧凑的文件，可以被发送到远程数据中心。
3. RDB最大限度强化了Redis的性能，因为在数据持久化时，Redis父进程所要做的工作，仅仅只是fork一个子进程。子进程会完成剩下的所有的持久化工作。父进程不需要进行磁盘IO相关的操作。
4. 在大数据场景下，相对AOF来说，RDB允许更快地重启服务。

关于RDB文件格式信息，可以参考：[Redis RDB Dump File Format](https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format)


#### RDB的劣势
1. 如果你想在服务故障（比如断电）导致Redis停止服务后，使数据丢失最小化，那么RDB可能并不能如你所愿。尽管你可以配置不同的 **save points** 来生成RDB文件，但是通常来说，你很可能配置Redis每隔5分钟（甚至更久）生成快照，所以万一Redis停止服务，你很可能丢失了最近的这几分钟的数据。对于有些应用，这种数据丢失可能是不能接受的。
2. RDB需要fork系统调用创建子进程来完成向磁盘的数据持久化。当数据很大时，fork系统调用非常耗时（比如当数据有几十GB时，可能需要几秒的时间）。这会导致Redis在此时间内停止服务（因为fork是在提供服务的Redis父进程中调用的）。AOF也需要调用fork，但是你可以调节日志记录的频率，且不需要在耐用性（durability，指Redis在频繁记录日志时依然能提供强大的服务能力）上做出权衡。

#### AOF的优势
1. 使用AOF时，Redis更加耐用。你可以配置不同的fsync策略：从不fsync；每秒fsync；或者每次查询fsync。默认的策略是每秒fsync，即便如此（频繁），Redis的写入性能依然很强劲（fsync是在后台线程中完成的，主线程会最大化提供写入的能力）。在这种fsync策略下，你可能丢失一秒内的写入操作（产生的数据）。
2. AOF日志是 **append only** 的，因此日志文件没有seek。这样的好处是，即便日志文件末尾是一条不完整的命令（由于磁盘满了或者其他原因）， redis-check-aof 工具依然能够轻松解决这个问题。
3. 当AOF过大时，Redis能自动在后台重写AOF。这个重写是安全的，因为Redis同时会继续追加旧的AOF文件。Redis通过几个操作来创建当前数据集的方式创建一个新的AOF文件，当第二个AOF文件准备好后，Redis会完成切换，开始追加日志到新的AOF文件。
4. AOF包含一个接一个的操作记录，这种格式易于理解和分析。举例来说，就算你通过FLUSHALL命令清空了所有数据，只要在此期间没有发生过AOF重写（上面第3点），你依然能恢复数据：停止服务；移除AOF日志里面的最后一条命令（FLUSHALL）；重启Redis。

#### AOF的劣势
1. AOF文件通常比相同数据集的RDB文件更大。
2. AOF可能比RDB慢，视实际的fsync策略而定。
3. 曾经我们遇到过少数的命令有bug，导致Redis重启时使用AOF恢复的数据与之前并不完全一致。这类型的bug在RDB持久化时几乎不可能发生。可以这么说：AOF的工作方式是逐步更新现有状态，而RDB快照则是一次次地创建完整的数据，这理论上更加符合鲁棒性。

然而，对于AOF持久化，还值得注意的是：
1. 每次Redis重写AOF时，都会从数据集中包含的**实际数据**开始重新创建。与始终追加同一个AOF相比，这使Redis抵御bug的能力更强。
2. 我们从未从用户那里获得关于在实际中检测到 AOF corruption 的报告。

#### Ok, so what should I use?
1. 一般而言，如果想要获得与PostgreSQL相当的数据安全性，你应该组合使用AOF和RDB。
2. 如果你的服务能接受在故障时有几分钟的数据丢失，那么简单地使用RDB即可。
3. 很多用户会单独使用AOF，但我们并不鼓励这么做。原因有：不断地为数据库生成快照在数据库备份的角度来看，是个很好的想法；更快地启动Redis服务；AOF的bug（以防万一出现）。

ps. 出于所有这些原因，未来Redis的这两种持久化选项可能会统一。