---
layout:         page
title:          【Go】Go高并发Part-1：操作系统调度器与Kernel Thread
date:           2020-05-16
author:         翼
header-img: image/bg.jpg
catalog: true
tags:
---

### 线程
一个程序即是一系列可被依序执行的机器指令。为了达到依序执行这些机器指令的目的，操作系统提供了线程的概念。线程被赋予了一系列的机器指令，并负责执行这些指令，直到线程中没有可供执行的指令。

每个程序被运行时，系统都会为它创建一个进程，这个进程又包含一个初始的线程，这个线程又可以创建额外的线程。操作系统的任务调度，就是基于这些线程，而不是基于进程。多个线程可以在同一个CPU核中并发执行，也能在多个CPU核中并行执行。

#### 线程-状态
线程的状态有下面三种，被操作系统调度器调度的线程，其状态会在这三种状态之间切换。
1. **Runnable**. 表示线程期望得到CPU时间片来执行它包含的机器指令。如果系统中有很多这样等待CPU时间片的线程，那么线程花在等待时间片上面的时间相应就会增多。
1. **Executing**. 表示线程已被切换入CPU核中，正在执行它包含的机器指令。
1. **Waiting**. 表示线程已被暂停，正在等待某些事件以便继续执行。比如等待磁盘、网络资源，进行系统调用或者同步调用。

#### 线程-任务类型
线程处理的任务，大体可以分为两类：
1. **CPU密集型**(CPU-Bound)：这种类型的任务的处理过程不会出现导致处理它的线程进入等待状态的情况，也就是持续进行计算的工作。
1. **IO密集型**（IO-Bound）：这种类型的任务会导致线程进入等待状态，比如访问网络资源，执行系统调用等等。

#### 线程-执行指令
线程通过**程序计数器**（program counter）来记录下一条指令（而非当前这条指令）的地址。
比如下面这个调用栈轨迹：
```go
goroutine 5 [select]:
github.com/patrickmn/go-cache.(*janitor).Run(0xc42001ba30, 0xc4200118c0)
	/home/webid/go/src/github.com/patrickmn/go-cache/cache.go:1079 +0x13b <- HERE
created by github.com/patrickmn/go-cache.runJanitor
	/home/webid/go/src/github.com/patrickmn/go-cache/cache.go:1099 +0xba <- HERE

```
末尾的数字表示的是相对于对应函数的程序计数偏移。**+0x13b** 代表了线程即将执行的那条指令相对于函数Run的偏移地址。

### 调度器
操作系统调度器负责任务调度，也就是**决定什么时候切换任务以及切换至哪个任务**。只要系统中还有能运行的线程，调度器就要确保CPU核不进入空闲状态。调度器会营造一种假象：系统中的线程是同时运行的。为了营造出这种假象，调度器采取线程优先级的策略，高优先级的线程优先于低优先级线程运行，但是又不能让低优先级线程“饿死”（持续处于Runnable状态）。同时，调度器还要做出最佳的调度策略，以便尽可能降低调度延迟。这一切，都是为了成功营造出“多个线程同时运行”的假象。

#### 调度器-上下文切换
Linux、Windows、Mac的操作系统都是抢占式的（preemptive）。抢占式意味着我们需要注意下面这两点：
1. 调度器也无法预知在某特定时间点，哪个线程会被选择运行。线程优先级、系统事件（例如socket接收到了数据）都会影响最终被选择进入CPU核中运行的线程。
1. 看似运行正确的程序，不一定就是正确的。比如说，如果程序依赖多个线程之间的运行顺序，那就必须控制线程同步等等，不能假设某个线程一定会比另一个线程先运行，即便是运行了几次测试，结果都没有问题。

交换CPU核中运行的线程，就是“上下文切换”：调度器“取出”CPU核中运行的线程，并且替换为另一个Runnable线程。可执行线程队列中的这个被选中的线程就进入**Executing状态**。而从CPU核中被移出的线程则变为**Runnable状态**（如果它还能继续执行的话），或者进入**Waiting状态**（如果它是因为一个IO请求或者其他原因才导致被移出CPU核进入等待状态）。

#### 调度器-上下文切换的代价
线程上下文切换的**代价是非常昂贵**的，上下文切换消耗的这段时间（可能在1K nanoseconds），也许够CPU核处理上万条机器指令。
1. 如果一个程序专注于IO密集型工作，那么上下文切换就能成为一种优势。当一个线程进入等待状态时，另一个可执行状态的线程就取而代之，被CPU核执行。这使得CPU核总是在工作的。这是调度器最重要的一项工作：只要还有工作没完成，就不应该让CPU核处于idle状态。
1. 如果一个程序专注于CPU密集型工作，那么上下文切换就可能是一个噩梦。

正因为内核线程的切换，代价太高，线程占用资源多，因此我们也**不能创建大量的线程**。否则，不仅线程占用的资源过多，调度器调度这么多的线程，也会明显增加调度工作本身带来的损耗。因此Go定义了goroutine这样的**用户级线程**。详情参考另外一篇《Go高并发Part-2：Go调度器》。

#### 调度器-少即是多（Less Is More）
根据上面介绍的上下文调度，有个结论：Runnable状态的线程越少，调度器的调度开销相对就越少，那么线程获得的可以运行的时间片就越多。当然，线程也并不是越少越好。我们必须找到一个平衡点，此时，“线程池”就是一种很好的方案。Go能支持高并发，其中一大原因就是因为Go原生使用了线程池的概念，这使得用Go开发支持高并发的系统，比传统的多线程开发更简单，因为我们不必花费精力去找到一个这样的“平衡点”。

### 缓存一致性
CPU核访问主内存的数据是一项非常耗时的操作，因此CPU核都会有一个本地缓存，数据会在主内存和CPU核的本地缓存之间进行交换。如果多核中运行的多个线程，访问的是同一块数据，那么每一个CPU核都会取到这块数据的一个副本。如果其中一个线程更新了缓存数据，硬件系统要负责把其他几个CPU核的本地缓存数据标记为脏数据（硬件的**缓存一致性协议**）。当一个线程访问脏数据缓存时，就必须从主内存中再次获取一份最新数据的副本。

试想一下，在一个拥有32个CPU核的系统中同时运行着的那么多线程，都在更新缓存数据的话，会发生什么情况？这种情况下，CPU核的本地缓存已经起不到什么作用了，程序的性能必然变得极差。这就是缓存一致性的问题。所以当我们编写多线程应用程序，并且多个线程都会更新共享的数据时，就必须考虑到CPU缓存的问题。

### 总结：内核线程的问题
总的来说，内核线程影响性能的几个主要因素有：
1. 线程的创建、调度、销毁的代价都不小。
1. 线程占用的资源太大，导致系统能创建的最大线程数有限。
1. 多线程共享内存时，缓存一致性问题可能很严重