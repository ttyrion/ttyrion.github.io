---
layout:         page
title:          【Go】Go编译指令
date:           2020-05-23
author:         翼
header-img: image/bg.jpg
catalog: true
tags:
---

通常，编译器都有些预定义好的编译指令（Compiler Directives），它们会影响编译过程以及编译结果。例如，VC++编译器的 **#pragma pack(N)**。Go也有一些编译指令，它们看起来有些像代码注释，不过，编译指令的"//"和指令之间是没有空格的。下面对几个在Go源码中比较常见的编译指令做些说明。

#### Escape Analysis: //go:noescape
欲了解此编译指令的作用，需要先连接Go的**Escape Analysis**（逃逸分析）。总所周知，在应用程序开发中涉及到的内存分配有两种：
1. 栈内存，在编译期间为函数分配。
1. 堆内存，在运行期间分配。
以C++为例，在函数内部定义的局部变量的内存，都由编译器编译时在栈上分配。而代码里面new/malloc的对象，都是在运行时分配的。

对Go来说，情况就不同了。即便是用函数new，也不见得内存就会被分配在堆上，也有可能还是在函数的栈上分配。到底在哪里分配，是由编译器决定的。为什么编译器会有这种行为？

这个问题涉及到两点：
1. 堆内存和栈内存的分别。栈内存会随着函数调用返回，自动回收。而堆内存需要我们主动去释放，否则内存开销越来越大，直到进程因内存不足而崩溃。
1. Go有GC。因为Go有GC机制，有专门的GC来负责将不能再访问的内存资源回收掉，而不需要Go开发者来主动释放内存。

问题在于，Go的GC工作时，会stopTheWorld，业务goroutine都会暂停运行。因此，GC的工作量越大，对业务系统的性能制约就越显著。所以，就需要有一个**Escape Analysis**机制，编译器根据分析结果，来检查内存是否必须要分配在堆上，或者说，分配在栈上也可以。编译器会判断这块内存需不需要跨栈共享（跨函数边界共享）。如果不需要，编译器就在栈上分配内存，否则，内存会被分配在堆上。

命令go build -gcflags -m 会打印出逃逸分析结果。
至此，也就能理解//go:noescape的作用了：声明它后面跟着的一个没有函数体的函数（即函数并不是用Go实现的）禁止逃逸分析，即所有内存都分配在栈上。

#### Escape Analysis: //go:nosplit